import * as pako from "pako";

export class Tools
{
    /**
     * Generate hash from a buffer.
     * @param data 
     */
    public static async Sha256(data: ArrayBuffer): Promise<string>
    {
        // For NodeJS compatibility
        if(typeof window === "undefined")
        {
            return new Promise<string>(resolve =>
            {
                const crypto = require("crypto");
                const hash = crypto.createHash("sha256");
    
                hash.on("readable", () =>
                {
                    const data = hash.read();

                    if (data) 
                    {
                        resolve(data.toString("hex"))
                    }
                });
            });
        }

        const hashBuffer = await crypto.subtle.digest("SHA-256", data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));

        return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    /**
     * Decompress data with ZLib.
     * @param data 
     */
    public static ZLibInflate(data: ArrayBuffer): ArrayBuffer
    {
        const array = pako.inflate(data) as Uint8Array;

        return array.buffer as ArrayBuffer;
    }

    /**
     * Compress data with ZLib.
     * @param data 
     */
    public static ZLibDeflate(data: ArrayBuffer): ArrayBuffer
    {
        const array = pako.deflate(data) as Uint8Array;

        return array.buffer as ArrayBuffer;
    }

    /**
     * Returns a random integer between min (included) and max (included).
     * @param min 
     * @param max 
     */
    public static Random(min: number, max: number): number
    {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    /**
     * Copy properties from one object to another.
     * @param to 
     * @param from 
     */
    public static Extract(to: Object, from: Object) 
    {
        for (let key in from) 
        {
            if(from.hasOwnProperty(key))
            {
                to[key] = from[key];
            }
        }
    }

    /**
     * Return the difference from source to target (properties of source).
     * @param source 
     * @param target 
     */
    public static Diff(source: Object, target: Object, limit: number = 3)
    {
        if(limit === 0 ||
            typeof source != "object" || 
            typeof target != "object" || 
            source === null || 
            target === null)
        {
            return null;
        }

        return Object.keys(source).reduce((diff, key) => 
        {
            switch(typeof source[key])
            {
                case "number":
                case "string":
                case "boolean":
                case "undefined":
                    if (source[key] != target[key])
                    {
                        return {
                            ...diff,
                            [key]: source[key]
                        }
                    }
                    break;
                case "object":
                    const sub = Tools.Diff(source[key], target[key], limit - 1);
                    
                    if(sub != null && Object.keys(sub).length)
                    {
                        return {
                            ...diff,
                            [key]: sub
                        }
                    }
                    break;
            }

            return diff;
        }, {});
    }
    
    /**
     * Bind properties from one object to another.
     * @param to 
     * @param from 
     */
    public static Bind(to: Object, from: Object, properties: string[]) 
    {
        for (let key in properties) 
        {
            const p = properties[key];

            if(from[p] !== undefined)
            {
                to[p] = from[p].bind(from);
            }
        }
    }

    /**
     * Unique ID generataion
     */
    public static Unique(): string 
    {
        let date = new Date().getTime();
        
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c =>
        {
            const r = (date + Math.random() * 16) % 16 | 0;

            date = Math.floor(date / 16);

            return (c === "x" ? r : (r & 0x7 | 0x8)).toString(16);
        });
    }

    /**
     * Check if the string is a unique ID generated by the Unique() function.
     * @param text 
     */
    public static IsUnique(text: string): boolean
    {
        const re = RegExp(
            "^[0-9a-fA-F]{8}-" + 
            "[0-9a-fA-F]{4}-" + 
            "4[0-9a-fA-F]{3}-" + 
            "[0-9a-fA-F]{4}-" + 
            "[0-9a-fA-F]{12}")

        return re.test(text);
    }

    /**
     * Hook into an object and intercept all function calls.
     * @param object 
     * @param hook Function to run before each call.
     */
    public static Hook(object: any, hook: (target, prop, args) => void) {
        return new Proxy(object,
            {
                get: (target, prop, receiver) => {
                    if (typeof target[prop] != "function") {
                        return Reflect.get(target, prop, receiver);
                    }

                    return (...args) => {
                        hook(target, prop, args);

                        return target[prop].bind(target)(...args);
                    }
                }
            });
    }

    /**
     * Wait some time.
     * @param delay 
     */
    public static async Wait(delay: number)
    {
        return new Promise<void>(resolve => 
        {
            setTimeout(() => resolve(), delay);
        });
    }

    /**
     * A noop function.
     */
    public static Noop(...args: any[]): any
    {
        return true;
    }

    public static ANSIToUTF16(buffer: ArrayBuffer): string 
    {
        const view = new Uint8Array(buffer);
        let result = "";

        for (let i = 0; i < view.byteLength; i++) 
        {
            result += String.fromCharCode(view[i]);
        }

        return result;
    }

    public static UTF16ToANSI(string: string): ArrayBuffer 
    {
        let buffer = new ArrayBuffer(string.length);
        let view = new Uint8Array(buffer);

        for (let i = 0; i < string.length; i++) 
        {
            view[i] = string.charCodeAt(i);
        }

        return buffer;
    }

    public static MergeBuffers(slices: ArrayBuffer[]): ArrayBuffer
    {
        let sumLength = 0;

        for(let buffer of slices)
        {
            sumLength += buffer.byteLength;
        }
        
        const merged = new Uint8Array(sumLength);
        let i = 0;

        for(let buffer of slices)
        {
            merged.set(new Uint8Array(buffer), i)

            i += buffer.byteLength;
        }

        return merged.buffer;
    }

    public static async RunAsync<T = void>(callback: () => T): Promise<T>
    {
        return new Promise(resolve => setTimeout(() => resolve(callback()), 0));
    }
}