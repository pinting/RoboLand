declare var navigator: { clipboard: any } & Navigator;

export class Tools
{
    /**
     * Returns a random integer between min (included) and max (included).
     * @param min 
     * @param max 
     */
    public static Random(min: number, max: number): number
    {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    /**
     * Copy properties from one object to another.
     * @param to 
     * @param from 
     */
    public static Extract(to: Object, from: Object) 
    {
        for (let key in from) 
        {
            if(from.hasOwnProperty(key))
            {
                to[key] = from[key];
            }
        }
    }

    /**
     * Return the difference from source to target (properties of source).
     * @param source 
     * @param target 
     */
    public static Diff(source: Object, target: Object, limit: number = 3)
    {
        if(limit === 0 ||
            typeof source != "object" || 
            typeof target != "object" || 
            source === null || 
            target === null)
        {
            return null;
        }

        return Object.keys(source).reduce((diff, key) => 
        {
            switch(typeof source[key])
            {
                case "number":
                case "string":
                case "boolean":
                case "undefined":
                    if (source[key] != target[key])
                    {
                        return {
                            ...diff,
                            [key]: source[key]
                        }
                    }
                    break;
                case "object":
                    const sub = Tools.Diff(source[key], target[key], limit - 1);
                    
                    if(sub != null && Object.keys(sub).length)
                    {
                        return {
                            ...diff,
                            [key]: sub
                        }
                    }
                    break;
            }

            return diff;
        }, {});
    }
    
    /**
     * Bind properties from one object to another.
     * @param to 
     * @param from 
     */
    public static Bind(to: Object, from: Object, properties: string[]) 
    {
        for (let key in properties) 
        {
            const p = properties[key];

            if(from[p] !== undefined)
            {
                to[p] = from[p].bind(from);
            }
        }
    }

    /**
     * Unique ID generataion
     */
    public static Unique(): string 
    {
        let date = new Date().getTime();
        
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c =>
        {
            const r = (date + Math.random() * 16) % 16 | 0;

            date = Math.floor(date / 16);

            return (c === "x" ? r : (r & 0x7 | 0x8)).toString(16);
        });
    }

    /**
     * Check if the string is a unique ID generated by the Unique() function.
     * @param text 
     */
    public static IsUnique(text: string): boolean
    {
        const re = RegExp(
            "^[0-9a-fA-F]{8}-" + 
            "[0-9a-fA-F]{4}-" + 
            "4[0-9a-fA-F]{3}-" + 
            "[0-9a-fA-F]{4}-" + 
            "[0-9a-fA-F]{12}")

        return re.test(text);
    }

    /**
     * Hook into an object and intercept all function calls.
     * @param object 
     * @param hook Function to run before each call.
     */
    public static Hook(object: any, hook: (target, prop, args) => void) {
        return new Proxy(object,
            {
                get: (target, prop, receiver) => {
                    if (typeof target[prop] != "function") {
                        return Reflect.get(target, prop, receiver);
                    }

                    return (...args) => {
                        hook(target, prop, args);

                        return target[prop].bind(target)(...args);
                    }
                }
            });
    }

    /**
     * Copy to clipboard.
     * @param text 
     */
    public static async Clipboard(text: string): Promise<boolean> 
    {
        const fallback = async (text) => 
        {
            return new Promise<boolean>(resolve => 
            {
                var field = document.createElement("textarea");
    
                field.value = text;
                document.body.appendChild(field);
    
                field.focus();
                field.select();
    
                try
                {
                    resolve(document.execCommand("copy"));
                }
                catch (e) {
                    resolve(false);
                }
    
                document.body.removeChild(field);
            });
        }

        if (!navigator.clipboard) 
        {
            return fallback(text);
        }

        try {
            await navigator.clipboard.writeText(text);
            return true;
        }
        catch(e)
        {
            return fallback(text);
        }
    }

    /**
     * Wait some time.
     * @param delay 
     */
    public static async Wait(delay: number)
    {
        return new Promise<void>(resolve => 
        {
            setTimeout(() => resolve(), delay);
        });
    }

    /**
     * A noop function.
     */
    public static Noop()
    {
        return;
    }
}